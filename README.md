# 13支卡牌偵測與出牌推薦系統
卡牌遊戲是一種使用撲克牌或卡片進行遊戲的活動，對大部分的人來說是一種休閒娛樂的活動，在空閒時可以跟朋友一起遊玩的遊戲，但對少部分的人來說卡牌遊戲是一個技術的比拚，策略的較量，一副相同的手牌可以根據不同的戰術打出不同的組合，但是當我們拿到一副手牌時，單以臨場的思考，卻難以知道怎麼樣的出牌方式在當下是最好的，有最高機率獲勝，因此我們想做出一個卡牌輔助系統，幫助玩家在拿到一副卡牌時能夠快速的計算出勝利期望值最高的出牌組合。  

我們選擇13張這款遊戲作為我們的目標，十三張是一種撲克遊戲，使用撲克牌型，雖然在不同地方13張的玩法也不同，但我們選擇較簡單好懂得遊戲規則。遊戲人數共4人，每人一開始拿13張，擺出頭中尾，頭要3張牌，中要五張牌，尾要五張牌，擺完後4個玩家分別進行頭中尾的比較牌型較大的玩家獲得該部位的獲勝，贏最多的玩家則可以拿下該場勝利。  

13張對比其他撲克牌的遊戲，他的手牌數是固定的，不會因為一些動作導致手牌增加或減少，也不像大老二一樣需要關注場上其他玩家的出牌，只需要找出自己手牌最好的出法，讓我們可以專注在計算自組牌勝率，因此我們選擇這款遊戲。

## 相關技術介紹
### ●	Python
Python是一種高階且直譯的程式語言，該語言強調程式碼可讀性與簡潔性。Python廣泛應用於軟體開發、資料科學、人工智慧、影像處理等領域，成為一個多用途的工具。相較於其他語言，Python的優勢之一是具備簡潔的語法，讓程式設計師能夠迅速理解與撰寫程式碼。此外Python還支援動態型別(Dynamically Type)，讓程式設計師無需宣告變數型別，以提升開發效率。  

Python的生態系統龐大，擁有豐富的內建函式庫與外部函式庫，包含各種模組和工具，較為有名且常使用的包含強大的資料處理庫NumPy，和機器學習庫TensorFlow，以及這次專案做即時影像偵測與處理時使用到的核心函式庫OpenCV。當然在網上(如Github)也有活躍的社群，程式設計師可以從全球各地的貢獻者中獲得支援，並參與許多開源的專案。  

### ●	Jupyter Notebook
Jupyer Notebook(以前被稱為IPython notebook)，是一個介於整合開發環境(IDE)以及程式碼編輯器(Editor)之間的一款用於撰寫程式碼的工具。該工具支援多種主流的直譯語言(如Python、R、Julia)，並透過直譯語言的特性執行程式，產生的執行結果除了能夠做到資料視覺化，也可以輸出成html的形式並嵌入到網頁中。而且由於使用該工具呈現的程式碼容易分享，網上許多資料分析、機器學習等平台上的討論都是以Jupyter Notebook的形式出現。  

啟動Jupyter Notebook之前，需要透過事先安裝的Anaconda Navigator，並在裡面的眾多工具中點選Jupyter notebook啟動工具。又或是直接安裝Jupyter Notebook，並透過命令提示字元中輸入啟動Jupyter Notebook的指令進行啟動。  

### ●	OpenCV
OpenCV(Open Source Computer Vision Library)是一個開源的電腦視覺函式庫，除了支援Python，也支持C++、Java等程式語言，更是提供豐富的功能如圖像處理、影像分割、物體識別、相機校準、三維重建等多個領域，使程式設計師能夠應用多種視覺處理技術在他們的專案項目上，而圖像處理的功能又涵蓋了圖像濾波、邊緣檢測、顏色空間轉換等技術以實現各種圖像操作。  

OpenCV的強大也體現在對機器學習的支援，它整合多種機器學習的算法如向量機（SVM）、決策樹、隨機森林等，在使用圖像處理等技術的同時搭配機器學習的使用，以提升辨別率等數值。該函式庫也擁有跨平台特性，無論是在Windows、Linux還是macOS皆能運行，也為程式設計師提供靈活性，以選擇最適合指定專案項目所需要的平台。  

### ●	win32gui
一個專門和Windows系統的圖形介面 (GUI) 互動的Python模組，該模組不僅提供程式設計師進行視窗的操作，如最小化、最大化、隱藏、顯示等，對於自動化測試、系統監控和應用程序自動化部署等情境時非常有用。而且該模組提供一系列的函數，讓程式設計師能夠獲取系統上所有視窗的詳細資訊，包括視窗的標題、大小、位置等。透過這些資訊，程式設計師可以做動態識別和定位特定的應用程式視窗，實現對該視窗的控制。  

此外win32gui還提供了模擬按鍵和滑鼠事件的功能，以利程式設計師以撰寫程式的方式模擬鍵盤輸入、滑鼠點擊和滾動等操作，進而實現自動化任務，提高工作效率。整體而言無論是需要在背景中自動執行任務、進行視窗管理、或是進行GUI測試，win32gui都提供眾多的功能和高自由度，但也需要謹慎使用，因為直接操作系統的GUI也可能導致不穩定且不可預期的結果。正確使用該模組需要深入了解Windows系統和目標應用程式的運作原理與方式，以確保程式的穩定性。  

### ●	PIL (Python Image Library)
PIL(全名為Python Image Library)，是一款優化程式設計師對圖像操作的Python圖像處理函式庫。這個函式庫提供打開、處理和保存各種圖像格式如JPEG、PNG、GIF或是BMP等，並提供簡單的API來操作這些圖像。其次，PIL也提供圖像處理功能，包含調整大小、裁剪、旋轉和翻轉等幾何變換，以對圖像進行改變並符合指定的規格。  

也可以使用濾波器如模糊、銳化和邊緣檢測，以創造獨特的視覺效果，以及讓程式設計師能夠添加特殊效果和改變圖像外觀的效果處理功能，如調整圖像色調、飽和度和亮度的色彩轉換，還有將文本和圖形添加到圖像上並調整圖像外觀和位置的文字與圖形繪製工具。這些功能同時象徵PIL不僅是圖像處理工具，也是個靈活的圖形生成工具。  

### ●	Spy++
Spy++是Microsoft Windows作業系統的偵錯和監視工具，該工具作為Visual Studio開發套件的一部分，為開發者提供深入了解Windows應用程式運作機制的途徑。Spy++能讓開發者瀏覽與理解桌面的視窗結構，並查看它們的層次關係、屬性和樣式，以及透過即時的視窗監視訊息的發送及接收，開發者能夠了解應用程式的使用者介面組織原理、視窗之間的相互關係，以及透過追蹤訊息，開發者能夠識別和解決與使用者輸入相關的問題，確保應用程式的穩定性。  

除了視窗和訊息監視外，開發者可以查看運行中的執行緒狀態、優先權和堆疊(Stack)呼叫，以及程序的模組化資訊，對於測試多執行緒的應用程式和理解程序間的溝通而言非常有幫助。對於我們的專案而言，我們查看並使用Spy++提供的視窗類別和名稱，將其輸入在win32gui的抓取視窗函式，以獲取特定視窗的畫面。  
![image](https://github.com/user-attachments/assets/daccffa2-f226-469a-a808-2a1f78b412c7)  

### ●	YOLO v8
YOLO (You Only Look Once)，是一種讓電腦快速識別圖片中的物體和物體位置的技術。YOLO物件偵測基於深度學習技術的一種方法，它將圖片分成很多小格子，然後分析每個格子中可能存在的物體和它們的位置。YOLO在分析過程中考慮物體的形狀、顏色等特徵，並與之前學習到的知識進行比對，最後得出圖片中物體的類型和位置。其優勢在於能夠在很短的時間內完成對圖片中物體的識別和定位，使得在很多需要實時反應的場景中具有很高的應用價值，如自動駕駛、監控系統等。  

## 系統架構與流程介紹
![image](https://github.com/user-attachments/assets/03e1549a-cee1-4f1a-82c9-88d33ccb3df5)  

### ●	YOLO模型製作
事先蒐集總計100場的遊戲畫面，代表總計13 * 100 = 1300張的卡牌樣本。  
![image](https://github.com/user-attachments/assets/0c52b052-a915-48bd-bfc0-1f3df825ef47)  
並將每張遊戲畫面的所有13張卡牌樣本，使用CVAT(Computer Vision Annotation Tool)進行標籤(Label)。  
![image](https://github.com/user-attachments/assets/bdf149d8-e24d-40c9-a26b-796b1f3905b7)  
標籤完成後將標籤好的資料從CVAT上下載，並將圖片與標籤資料分為三個資料夾  
> ●	訓練集（train）：訓練模型中參數的資料，就像是上課學習。  
> ●	驗證集（valid）：根據驗證資料調整模型參數，就像是模擬考，你會根據模擬考的成績繼續學習、或調整學習方式重新學習。  
> ●	測試集（test）：經過上面兩項，最後正式測試出來的結果，就像是大考(如：多益)評估你最終的學習結果。  

將個別資料夾的資料數量比例分為訓練:驗證:測試 = 80：10：10。  
新增一個data.yaml檔案，附上訓練集、驗證集、測試集資料夾的路徑位置，並且註明訓練的標籤數量以及所有標籤名稱。
![image](https://github.com/user-attachments/assets/ffaee2fb-2312-49fc-ab0e-f24e49c9b5c7)  
![image](https://github.com/user-attachments/assets/f3dd7572-2b37-40cd-8e13-fec99b19399d)  

所有資料放到雲端硬碟後，使用Google Colab並透過data.yaml檔案進行模型訓練。最後輸出訓練完成的模型檔案(.pt檔)。  
![image](https://github.com/user-attachments/assets/c971d646-464f-4ac0-8a8e-0103e329096e)  
![image](https://github.com/user-attachments/assets/64789215-4601-4e1d-a659-58ceb3d1183a)  

### ●	截圖畫面
我們會透過Python中 OpenCV、win32gui、Spy++、PIL的功能來完成我們的截圖功能。  
首先，我們透過win32gui中的FindWindow找到想要截圖的視窗，但是視窗的類別名稱一般的方式找不到，所以我們使用Spy++這項工具來搜尋視窗的類別名稱和標題。  
```
hwnd = win32gui.FindWindow(param1, param2)
# param1 為窗口的類別名稱
# param2 為窗口的標題，意旨視窗左上角的名稱
```  
之後透過GetWindowRect找出我們指定視窗的絕對位置。  
> ●	left為視窗的左側距離銀幕左邊的值  
> ●	top為視窗的的上面距離螢幕頂部的值  
> ●	right為視窗的右側距離銀幕左邊的值  
> ●	bot為視窗的的下面距離螢幕頂部的值  

```
left, top, right, bot = win32gui.GetWindowRect(hwnd)
# 找到電腦螢幕距離左、上、右、下各自的距離
```
透過PIL中的ImageGrab進行抓取，使用bbox參數來選定想要抓取的框架大小和位置，而我們透過前面獲得的視窗的座標，就能精準抓取到視窗的範圍。
```
img = ImageGrab.grab(bbox = (left, top, right, bot))
# 抓取當前螢幕(left, top, right, bot)匡列的範圍
```

### ●	YOLO卡牌判定
![image](https://github.com/user-attachments/assets/56d4c69a-d44d-49e2-9549-0c2f42ebbad5)  
我們會先載入YOLO的模型。  
```
model = YOLO("detect_model.pt")
```
設定一個全域變數來接收我們模型偵測出來的13張卡牌的label。  
```
global Card
```
把截圖的畫面丟進模型之中。  
```
results = model(window, verbose=False)[0]
```
然後使用for迴圈把偵測到的每行list中的資料儲存到x1,y1,x2,y2,score,class_id 之中。  
```
for result in results.box.data.tolist():
  x1, y1, x2, y2, score,class_id = result
```
透過判定是否達標(怕偵測出錯也被加進去)，然後把偵測到卡牌框起來，並標出卡牌的label。之後透過Card.append(results.names[int(class_id)])把label加進list之中，並透過list(set(Card))把重複的label給去掉。而 if len(Card)>13是在偵測list是否超過13張，如果超過代表有問題，就把整個list清掉並跳到下一幀畫面來執行輸出。  
```
if score > threshold:
  cv2.rectangle(window, (int(x1), int(y1)), (int(x2), int(y2)), (0, 255, 0), 4)
  cv2.putText(window, result.names[int(class_id)], (int(x1), int(y1 - 10)), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0))
  Card.append(results.names[int(class_id)])
  Card = list(set(Card))
  if len(Card) > 13:
    Card = []
```
輸出結果  
![image](https://github.com/user-attachments/assets/03bc2c09-6243-4ee8-a90f-e98c8e70306a)  
![image](https://github.com/user-attachments/assets/0807af49-9a05-4179-b048-44b43e245f06)  
我們把輸出的陣列進行轉換依照下圖進行轉換。  
> AC對應"梅花A"之後會轉成1、AH對應"愛心A"之後會轉成3、QS對應"黑桃Q"之後會轉成48以此類推。  

![image](https://github.com/user-attachments/assets/64470423-0acf-4151-b7f8-245f53502c82)

### ●	輸出結果
最後我們會把檢測出來的13張撲克牌的list透過程式轉成數字的形式的list並輸出出去。  
```
def poker_transform():
  global Card
  for i in range(len(Card)):
    #A
    if Card[i] == "AC":
      Card[i] = 1
    if Card[i] == "AD":
      Card[i] = 2
    if Card[i] == "AH":
      Card[i] = 3
    if Card[i] == "AS":
      Card[i] = 4

    #2
    if Card[i] == "2C":
      Card[i] = 5
    if Card[i] == "2D":
      Card[i] = 6
    if Card[i] == "2H":
      Card[i] = 7
    if Card[i] == "2S":
      Card[i] = 8

    ...
```
```
['4C', '6C', 'JC', 'QD', '10D', '10H', '9C', '7D', '6H', '5D', 'QC', '7H', ''2H]
```
轉換為  
```
[13, 21, 41, 46, 38, 39, 33, 26, 23, 18, 45, 27, 7]
```

### ●	取得資料
取得從畫面擷取轉換成矩陣的資料後，將矩陣重新由小到大進行排列方便之後的運算。  
```
card # 取得的矩陣資料
card = sorted(card) # 對矩陣進行由小到大的排列
```

### ●	列出組合
從取得的13張牌中找出所有 C(13, 3) * C(10, 5) * C(5, 5) 組合。  
首先先列出所有從13張裡面取出3張的組合每個組合把原先的矩陣跟取出來的3張做差集就得到剩下來的10張，再列出所有從10張裡面取出5張的組合，每一個組合在跟原先的10張取差集就會得到剩下的五張，做完這些步驟就能得到所有的組合。  
```
from itertools import combinations

b = [1,2,3,4,5,6,7,8,9,10,11,12,13]  # 初始的13張
b1 = [0,0,0]  # 第一輪的矩陣
b2 = [0,0,0,0,0]  # 第二輪的矩陣

r1 = list(combinations(b, 3))
j1 = 0  # 轉換組的計數器
j2 = 0  # 取5後轉換組的計數器

# 計算所有組合
for j in r1:
    i = 0
    n = 0
    # 在13張中取3張，計算組合
    while i < 3:
        b1[n] = r1[j1][i]
        n += 1
        i += 1

    j1 += 1
    c1 = list(set(b).difference(set(b1)))  # 再把取出來的取差集相同的消掉
    print(c1)

  # 在剩餘的牌中取5張，看有多少組合
  r2 = list(combinations(c1, 5))
  b2 = [0,0,0,0,0]
  j2 = 0

  for j in r2: #再計算出取五張後的所有組合
    i = 0
    n = 0
    while i < 5:
        b2[n] = r2[j2][i]
        i += 1
        n += 1
    j2 += 1

    c2 = list(set(c1).difference(set(b2)))  # 剩餘的牌
    print(b1, b2, c2)
```

### ●	判定牌型
判定每個小組中所形成的最大牌型。  
為了方便判斷牌型，我們首先會將數字相同的牌分為一個小組。  
| 數字 | 梅花 | 方塊 | 紅心 | 黑桃 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 1 | 1 | 2 | 3 | 4 |
| 2 |	5 |	6 |	7 |	8 |
| 3 |	9 |	10 | 11 |	12 |
| 4 |	13 | 14 |	15 | 16 |
| 5 |	17 | 18 |	19 | 20 |
| 6 |	21 | 22 |	23 | 24 |
| 7 |	25 | 26	| 27 | 28 |
| 8 |	29 | 30	| 31 | 32 |
| 9 |	33 | 34	| 35 | 36 |
| 10 | 37 |	38 | 39 |	40 |
| 11 | 41 |	42 | 43 |	44 |
| 12 | 45 |	46 | 47 |	48 |
| 13 | 49 |	50 | 51 |	52 |

並且使用函式team(x)來判斷數字x屬於哪個組別  
判定規則：一條龍＞同花順＞鐵枝＞葫蘆＞同花＞順子＞三條＞兩對＞對子＞散牌  

1. 一條龍  
```
if team(Card[0])==1:
  if team(Card[1])==2:
    …以此類推
    …if team(Card[13])==13:
```
2. 同花順
```
if Card[0]+4==Card[1]:
  if Card[1]+4==Card[2]:
    if Card[2]+4==Card[3]:
      if Card[3]+4==Card[4]:
        if Card[4]+4==Card[5]:
```
因已經過排序，不用擔心順序問題  
3. 鐵枝  
考慮前四張一樣或後四張一樣的情形  
```
if team(Card[0])==team(Card[1]):
	if team(Card[1])==team(Card[2]):
		if team(Card[2])==team(Card[3]):
			if team(Card[3])==team(Card[4]):
elif team(Card[1])==team(Card[2]):
	if team(Card[2])==team(Card[3]):
		if team(Card[3])==team(Card[4]):
			if team(Card[4])==team(Card[5]):
```
4. 葫蘆  
考慮前三張一樣且後兩張一樣或前兩張一樣且後三張一樣的情形  
5. 同花  
```
if Card[0]%4==Card[1]:
	if Card[1]%4==Card[2]:
		if Card[2]%4==Card[3]:
			if Card[3]%4==Card[4]:
				if Card[4]%4==Card[5]:
```
6. 順子  
```
if team(Card[0])+1==team(Card[1]):
	if team(Card[1])+1==team(Card[2]):
		if team(Card[2])+1==team(Card[3]):
			if team(Card[3])+1==team(Card[4]):
```
7. 三條  
考慮前三張、中間三張、後三張數字相同的情形  
```
if team(Card[0])==team(Card[1]):
	if team(Card[1])==team(Card[2]):
elif team(Card[1])==team(Card[2]):
	if team(Card[2])==team(Card[3]):
elif team(Card[2])==team(Card[3]):
	if team(Card[3])==team(Card[4]):
```
8. 兩對  
```
if team(Card[0])==team(Card[1]):
	if team(Card[2])==team(Card[3]):
	elif team(Card[3])==team(Card[4]):
elif team(Card[1])==team(Card[2]):
  if team(Card[3])==team(Card[4]):
```
9. 對子  
```
if team(Card[0])==team(Card[1]):
elif team(Card[1])==team(Card[2]):
elif team(Card[2])==team(Card[3]):
elif team(Card[3])==team(Card[4]):
```
10. 散牌  
```
else 皆為散牌
```
一條龍＞同花順＞鐵枝＞葫蘆＞同花＞順子＞三條＞兩對＞對子＞散牌  
牌型判定完成後，需要決定作為該組合代表的牌。  
> 花色排序:黑桃>紅心>方塊>梅花  
> 例如:以黑桃A作為結尾的同花順，會比以梅花A作為結尾的同花順，多贏過3個組合。  

以下是判定代表牌數字的方式
| 牌型 | 說明 |
| ------------- | ------------- |
| 一條龍、同花順、同花、順子、散牌 | 直接以組合中數字最大者(Card[4])為代表 |
| 鐵枝 | 以有四個同組的該數字為代表 |
| 葫蘆、三條 |	以有三個重複數字的數字為代表 |
| 對子 | 以有兩個重複數字的數字為代表 |
| 兩對 | 將兩組重複數字進行比較，較大者為代表 |  
接著將代表的數字使用4取餘數，即可知道花色。  

### ●	判定期望值
牌型判定完成後，根據牌型勝率計算出獲勝的期望值 例如，以梅花1作為結尾的同花順，在2598960種組合中能贏過2598956種組合。  
則我們假設此同花順在那一輪的勝率是2598956/2598960=約99.9999% ，以此類推。  
![image](https://github.com/user-attachments/assets/6d2d1909-7c02-418f-b80b-5159af71188d)  
之後分別以兩種策略顯示給使用者：  
1. 三組牌的的期望值加總最高組合  
2. 任意兩組牌的期望值相乘最高組合  
讓使用者自行選擇使用的策略。  

## 最終呈現畫面
![image](https://github.com/user-attachments/assets/86c41e16-b420-4111-a078-9c30ec22e8c2)  

## 實驗結果
當初我們制定優先度判定規則時，是依照某組員以前玩過的遊戲規則所制定，然而我們遍巡各種手機程式，卻沒有一款是依照相同的規則，因此我們改採用組員親自人工試驗的方式，讓使用程式者使用「兩局相乘最高」的結果，與兩位有遊玩經驗的組員和一位無遊玩經驗的組員遊玩十局，以下是我們的實驗結果：  
| 第一局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | -1 | 3 | 1 | -3 |
| 第二場 | 1 | -1 | -3 | 3 |
| 第三場 | -1 | -3 | 3 | 1 |
| 總計 | -1 | -1 | 1 | 1 |

| 第二局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | -3 | 3 | 1 | -1 |
| 第二場 | 3 | 1 | -1 | -3 |
| 第三場 | -1 | 1 | 3 | -3 |
| 總計 | -1 | 5 | 3 | -7 |

| 第三局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | 1 | -3 | -1 | 3 |
| 第二場 | 1 | 3 | -1 | -3 |
| 第三場 | 1 | 3 | -1 | -3 |
| 總計 | 3 | 3 | -3 | -3 |

| 第四局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | -3 | 1 | 3 | -1 |
| 第二場 | 3 | -3 | -1 | 1 |
| 第三場 | 3 | -3 | -1 | 1 |
| 總計 | 3 | -5 | 1 | 1 |

| 第五局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | 3 | 1 | -1 | -3 |
| 第二場 | -1 | -3 | 1 | 3 |
| 第三場 | -1 | -3 | 3 | 1 |
| 總計 | 1 | -5 | 3 | 1 |

| 第六局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | 1 | -3 | 3 | -1 |
| 第二場 | 3 | -1 | 1 | -3 |
| 第三場 | 1 | 3 | -3 | -1 |
| 總計 | 5 | -1 | 1 | -5 |

| 第七局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | 1 | 3 | -1 | -3 |
| 第二場 | 1 | 3 | -1 | -3 |
| 第三場 | -1 | -3 | 1 | 3 |
| 總計 | 1 | 3 | -1 | -3 |

| 第八局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | -3 | 1 | 3 | -1 |
| 第二場 | -3 | -1 | 1 | 3 |
| 第三場 | -1 | 3 | -3 | 1 |
| 總計 | -7 | 3 | 1 | 3 |

| 第九局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | -3 | 1 | 3 | -1 |
| 第二場 | 1 | -1 | 3 | -3 |
| 第三場 | 3 | 1 | -3 | -1 |
| 總計 | 1 | 1 | 3 | -5 |

| 第十局 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 第一場 | 1 | 3 | -1 | -3 |
| 第二場 | 1 | 3 | -1 | -3 |
| 第三場 | -3 | -1 | 3 | 1 |
| 總計 | -1 | 5 | 1 | -5 |

| 最終統計 | 判定系統 | 有經驗者1 | 有經驗者2 | 無經驗者 |
| ------------- | ------------- | ------------- | ------------- | ------------- |
|  | 4 | 8 | 10 | -22 |

由此結果可以發現，此系統的判定會優於無經驗者的出牌方式，表示其仍能一定程度的接近最好出牌方式，然而若是與有經驗者比較，就會因策略過於單純而吃虧，顯示其演算法仍有優化空間。

## 結論
藉由這次的開發經驗，我們得到了面向使用者的開發經驗，也體會到了細細鑽研出牌策略的樂趣，未來我們也能將類似的技術擴展至其他的撲克牌遊戲，甚至是其他我們感興趣的卡牌遊戲上，是一項既實用又有趣的專案。  

## 附錄
### ●	工作分配
| 組員 | 工作 |
| ------------- | ------------- |
| @turtledove34 | 判定機制設計、簡報、word製作 |
| @yuyuson | 圖形處理設計、簡報、word製作 |
| @hanson4226 | 判定機制設計、簡報、word製作 |
| @YuOAO-dreamlife | 圖形處理設計、簡報、word製作 |

### ●	參考資料
[1] [擷取螢幕畫面參考](https://hutdris.blogspot.com/2016/11/pythonopencv.html)  

[2] [擷取螢幕畫面參考含Spy++](https://blog.csdn.net/ztmajor/article/details/105376319)  

[3] [撲克牌辨識](https://github.com/EdjeElectronics/OpenCV-Playing-Card-Detector)  

[4] [牌型出現機率](https://zh.wikipedia.org/zh-tw/%E6%92%B2%E5%85%8B%E7%89%8C%E5%9E%8B)  
